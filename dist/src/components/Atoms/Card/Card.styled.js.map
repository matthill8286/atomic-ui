{"version":3,"file":"Card.styled.js","sources":["../../../../../src/components/Atoms/Card/Card.styled.ts"],"sourcesContent":["import { darken } from 'polished'\nimport { media } from '@/styles'\nimport { css, styled } from '@/styles/styled'\nimport {\n  Elevation,\n  HorizontalMargin,\n  HorizontalPadding,\n  Margin,\n  Padding,\n  Position,\n  ThemeColors,\n  VerticalMargin,\n  VerticalMarginMap,\n  VerticalPadding,\n  VerticalPaddingMap,\n} from '@/types/theme'\nimport { Picture } from '../Picture'\nimport {\n  Corners,\n  Shape,\n  StyledBadgeWrapperProps,\n  StyledCardProps,\n  StyledDividerProps,\n  Surface,\n} from './Card.interface'\n\nexport const StyledBadgeLineWrapper = styled.div<StyledBadgeWrapperProps>`\n  position: absolute;\n  left: 0;\n  top: -14px;\n  max-width: 100%;\n  z-index: 1; /* required because transform interferes with z-order */\n\n  ${media.maxMd} {\n    > div > div:nth-child(n + 3) {\n      display: none;\n    }\n  }\n`\n\nconst handleElevation = (elevation: Elevation, surface: Surface = 'white') => {\n  return ({ theme }) => {\n    if (surface === 'selected') {\n      const elevationAsStyleString = elevation\n        ? `${theme.dimension[`elevationLevel${elevation}`]}, `\n        : ''\n      return `${elevationAsStyleString}inset 0px 0px 0px 2px ${theme.color.primary}`\n    }\n\n    return theme.dimension[`elevationLevel${elevation}`]\n  }\n}\n\nexport const handlePadding = (\n  baseSpacing: Record<string, unknown>,\n  padding: VerticalPadding | VerticalPaddingMap | Padding\n): string => {\n  let paddingCss = ''\n  let responsivePaddingCss = ''\n  const { top, right, bottom, left } = padding as Padding\n  const overallPadding = padding as HorizontalPadding\n  const { mobile, tablet, desktop } = padding as VerticalPaddingMap\n\n  // set a padding for all sides if prop e.g. padding=\"sm\"\n  if (overallPadding && baseSpacing[overallPadding]) {\n    paddingCss = `padding: ${baseSpacing[overallPadding]};`\n  }\n\n  // add padding for one side if prop has attribute: padding={{top: 'sm'}}\n  if (top) {\n    responsivePaddingCss = responsivePaddingCss + `padding-top: ${baseSpacing[top]};`\n  }\n\n  // add padding for one side if prop has attribute: padding={{right: 'lg'}}\n  if (right) {\n    responsivePaddingCss = responsivePaddingCss + `padding-right: ${baseSpacing[right]};`\n  }\n\n  // add padding for one side if prop has attribute: padding={{bottom: 'xxs'}}\n  if (bottom) {\n    responsivePaddingCss = responsivePaddingCss + `padding-bottom: ${baseSpacing[bottom]};`\n  }\n\n  // add padding for one side if prop has attribute: padding={{left: 'xl'}}\n  if (left) {\n    responsivePaddingCss = responsivePaddingCss + `padding-left: ${baseSpacing[left]};`\n  }\n\n  // add padding rule for mobile, if a single side was set above, only the other sides will be affected\n  if (mobile) {\n    paddingCss =\n      paddingCss + `${media.mobile} {padding: ${baseSpacing[mobile]}; ${responsivePaddingCss}};`\n  }\n\n  // add padding rule for tablet, if a single side was set above, only the other sides will be affected\n  if (tablet) {\n    paddingCss =\n      paddingCss + `${media.tablet} {padding: ${baseSpacing[tablet]}; ${responsivePaddingCss}};`\n  }\n\n  // add padding rule for desktop, if a single side was set above, only the other sides will be affected\n  if (desktop) {\n    paddingCss =\n      paddingCss + `${media.desktop} {padding: ${baseSpacing[desktop]}; ${responsivePaddingCss}};`\n  }\n\n  return paddingCss || responsivePaddingCss\n}\n\nexport const handleMargin = (\n  baseSpacing: Record<string, unknown>,\n  margin: VerticalMarginMap | VerticalMargin | Margin\n): string => {\n  let marginCss = ''\n  let responsiveMarginCss = ''\n  const { top, right, bottom, left } = margin as Margin\n  const overallMargin = margin as HorizontalMargin\n  const { mobile, tablet, desktop } = margin as VerticalMarginMap\n\n  // set a margin for all sides if prop e.g. margin=\"sm\"\n  if (overallMargin && baseSpacing[overallMargin]) {\n    marginCss = `margin: ${baseSpacing[overallMargin]};`\n  }\n\n  // add margin for one side if prop has attribute: margin={{top: 'sm'}}\n  if (top) {\n    responsiveMarginCss = responsiveMarginCss + `margin-top: ${baseSpacing[top]};`\n  }\n\n  // add margin for one side if prop has attribute: margin={{right: 'lg'}}\n  if (right) {\n    responsiveMarginCss = responsiveMarginCss + `margin-right: ${baseSpacing[right]};`\n  }\n\n  // add margin for one side if prop has attribute: margin={{bottom: 'xxs'}}\n  if (bottom) {\n    responsiveMarginCss = responsiveMarginCss + `margin-bottom: ${baseSpacing[bottom]};`\n  }\n\n  // add margin for one side if prop has attribute: margin={{left: 'xl'}}\n  if (left) {\n    responsiveMarginCss = responsiveMarginCss + `margin-left: ${baseSpacing[left]};`\n  }\n\n  // add margin rule for mobile, if a single side was set above, only the other sides will be affected\n  if (mobile) {\n    marginCss =\n      marginCss + `${media.mobile} {margin: ${baseSpacing[mobile]}; ${responsiveMarginCss}};`\n  }\n\n  // add margin rule for tablet, if a single side was set above, only the other sides will be affected\n  if (tablet) {\n    marginCss =\n      marginCss + `${media.tablet} {margin: ${baseSpacing[tablet]}; ${responsiveMarginCss}};`\n  }\n\n  // add margin rule for desktop, if a single side was set above, only the other sides will be affected\n  if (desktop) {\n    marginCss =\n      marginCss + `${media.desktop} {margin: ${baseSpacing[desktop]}; ${responsiveMarginCss}};`\n  }\n\n  return marginCss || responsiveMarginCss\n}\n\nconst handleBorder = (surface: Surface, borderWidth: number, borderColor?: ThemeColors) => {\n  return ({ theme }) => {\n    const surfaces = {\n      white: theme.color.grey2,\n      clear: theme.color.grey2,\n      grey: theme.color.grey2,\n      black: theme.color.grey5,\n      primary: theme.color.primary,\n      selected: theme.color.selected,\n    }\n\n    let finalBorderColor\n\n    if (borderColor) {\n      finalBorderColor = theme.color[borderColor]\n    } else if (surface === 'primary') {\n      finalBorderColor = darken(theme.polished.darken, theme.color.primary)\n    } else {\n      finalBorderColor = surfaces[surface]\n    }\n    return `${borderWidth}px solid ${finalBorderColor}`\n  }\n}\n\nconst handleColor = (textColor?: ThemeColors, surface?: Surface) => {\n  return ({ theme }) => {\n    switch (surface) {\n      case 'black':\n      case 'primary':\n        return theme.color.white\n      case 'selected':\n        return theme.color.black\n      default:\n        return theme.color[textColor || 'black']\n    }\n  }\n}\n\nconst isCornersShape = (shape: Shape | Corners<Shape>): shape is Corners<Shape> => {\n  const typedShape = shape as Corners<Shape>\n  return (\n    !!typedShape.bottomLeft ||\n    !!typedShape.bottomRight ||\n    !!typedShape.topLeft ||\n    !!typedShape.topRight\n  )\n}\n\nexport const handleShape = (shape: Shape | Corners<Shape>) => {\n  return ({ theme }) => {\n    const borders = {\n      sharp: theme.dimension.borderRadius0,\n      'rounded-small': theme.dimension.borderRadius1,\n      'rounded-big': theme.dimension.borderRadius2,\n      'rounded-xl': theme.dimension.borderRadius3,\n    }\n    if (isCornersShape(shape)) {\n      const { bottomRight, bottomLeft, topLeft, topRight } = shape\n      return `\n        ${topLeft && `border-top-left-radius: ${borders[topLeft]};`}\n        ${topRight && `border-top-right-radius: ${borders[topRight]};`}\n        ${bottomLeft && `border-bottom-left-radius: ${borders[bottomLeft]};`}\n        ${bottomRight && `border-bottom-right-radius: ${borders[bottomRight]};`}\n      `\n    } else {\n      return `border-radius: ${borders[shape]};`\n    }\n  }\n}\n\nconst handleSurface = (surface?: Surface) => {\n  return ({ theme }) => {\n    const surfaces = {\n      white: theme.color.white,\n      grey: theme.color.grey4,\n      black: theme.color.grey6,\n      primary: theme.color.primary,\n      selected: theme.color.white,\n    }\n    return 'background-color: ' + surfaces[surface ? surface : 'white'] + ';'\n  }\n}\n\nconst handleNoBorder = (noBorder: Position | Position[] | 'none'): string => {\n  if (noBorder === 'none') {\n    return `border: none;`\n  }\n\n  if (Array.isArray(noBorder)) {\n    return noBorder.map(position => `border-${position}-width: 0px;`).join('')\n  } else {\n    return `border-${noBorder}-width: 0px;`\n  }\n}\n\nconst handleElevationHover = (\n  elevationHover: Elevation,\n  elevation: Elevation,\n  surface?: Surface\n) => css<StyledCardProps>`\n  cursor: pointer;\n  transition-duration: 0.15s;\n  transition-timing-function: ease-in-out;\n  transition-property: border-color, box-shadow, transform;\n\n  ${media.tablet} {\n    &:hover {\n      transform: ${elevationHover > 0 && elevationHover !== elevation\n        ? 'translateY(-1px)'\n        : 'none'};\n      box-shadow: ${handleElevation(elevationHover, surface)};\n      border-color: rgba(0, 0, 0, 0);\n    }\n  }\n`\n\nexport const StyledCard = styled.div<StyledCardProps>(\n  ({\n    borderColor,\n    borderWidth,\n    center,\n    display,\n    elevation,\n    elevationHover,\n    margin,\n    noBorder,\n    overflow,\n    padding,\n    cardHeight,\n    flexDirection,\n    shape,\n    surface,\n    textColor,\n    theme,\n  }) => css<StyledCardProps>`\n    ${display && `display: ${display};`};\n    ${flexDirection && `flex-direction: ${flexDirection};`};\n    box-sizing: border-box;\n    line-height: 1.43;\n    overflow: ${overflow ? overflow : 'hidden'};\n    ${!!padding && handlePadding(theme.spacing.base, padding as VerticalPaddingMap)};\n    ${!!margin && handleMargin(theme.spacing.base, margin)};\n    box-shadow: ${handleElevation(elevation, surface)};\n    color: ${handleColor(textColor, surface)};\n    border: ${elevation === 0 && handleBorder(surface ?? 'white', borderWidth, borderColor)};\n    ${surface && handleSurface(surface)}\n    ${noBorder && handleNoBorder(noBorder)}\n    ${!!elevationHover && handleElevationHover(elevationHover, elevation, surface)}\n    ${shape && handleShape(shape)}\n    ${center && `text-align: center;`}\n    height: ${cardHeight ? cardHeight : '100%'};\n    width: 100%;\n\n    h1,\n    h2,\n    h3,\n    h4,\n    h5,\n    h6 {\n      color: ${(surface === 'grey' || surface === 'primary' || surface === 'black') &&\n        theme.color.white};\n    }\n  `\n)\n\nexport const StyledFeaturedAssetsPicture = styled(Picture)`\n  & img {\n    display: block;\n    /* Need to set max width on assets here because it's overwritten in multiple places by carousel styles :-() */\n    max-width: 128px !important;\n  }\n`\n\nexport const StyledFeaturedAssetsContainer = styled.div`\n  display: none;\n  ${media.tablet} {\n    position: absolute;\n    display: flex;\n    z-index: 1;\n    right: 0;\n    top: -24px;\n    justify-content: flex-end;\n  }\n`\n\nexport const StyledFeaturedAssetSpacing = styled.div(\n  ({ theme }) => css`\n    margin-left: ${theme.spacing.base.xs};\n  `\n)\n\nexport const StyledDivider = styled.div<StyledDividerProps>(\n  ({ dividerWidth, theme }) =>\n    css<StyledDividerProps>`\n      position: absolute;\n      bottom: 1px;\n      left: calc(calc(100% - ${dividerWidth}) / 2);\n      display: flex;\n      width: ${dividerWidth};\n      margin: 0 auto;\n      z-index: 1;\n      background: ${theme.color.grey2};\n      height: 1px;\n    `\n)\n\nexport const StyledCardWrapper = styled.div<{\n  fullHeight: boolean\n  elevationHover?: Elevation\n  cardHeight?: string\n}>`\n  position: relative;\n  outline: none;\n  width: 100%;\n\n  ${StyledBadgeLineWrapper} {\n    transition-duration: 0.15s;\n    transition-timing-function: ease-in-out;\n    transition-property: transform;\n  }\n\n  ${media.tablet} {\n    &:hover {\n      ${StyledBadgeLineWrapper}, ${StyledFeaturedAssetsContainer} {\n        transform: ${({ elevationHover }) =>\n          elevationHover && elevationHover > 0 ? 'translateY(-1px)' : 'none'};\n      }\n    }\n  }\n\n  ${({ fullHeight }) =>\n    fullHeight &&\n    css`\n      height: 100%;\n    `}\n\n  ${({ cardHeight }) =>\n    cardHeight &&\n    css`\n      height: ${cardHeight};\n    `}\n`\n"],"names":["StyledBadgeLineWrapper","styled","div","media","maxMd","handleElevation","elevation","surface","theme","elevationAsStyleString","dimension","color","primary","handlePadding","baseSpacing","padding","paddingCss","responsivePaddingCss","top","right","bottom","left","overallPadding","mobile","tablet","desktop","handleMargin","margin","marginCss","responsiveMarginCss","overallMargin","handleShape","shape","borders","sharp","borderRadius0","borderRadius1","borderRadius2","borderRadius3","typedShape","bottomLeft","bottomRight","topLeft","topRight","isCornersShape","StyledCard","borderColor","borderWidth","center","display","elevationHover","noBorder","overflow","cardHeight","flexDirection","textColor","css","spacing","base","white","black","handleColor","finalBorderColor","surfaces","grey2","clear","grey","grey5","selected","darken","polished","handleBorder","grey4","grey6","handleSurface","Array","isArray","map","position","join","handleNoBorder","handleElevationHover","StyledFeaturedAssetsPicture","Picture","StyledFeaturedAssetsContainer","StyledFeaturedAssetSpacing","xs","StyledDivider","dividerWidth","StyledCardWrapper","fullHeight"],"mappings":"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"}